<!doctype html>
<!--
Copyright 2018 Google, Inc. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
-->
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">
<link rel="stylesheet" href="style.css">

<div class="bar">
</div>
<header class="profile">
  <img src="avatar.jpg" class="avatar">
  <h1 class="name">Surma</h1>
  <h2 class="handle">@DasSurma</h2>
  <section class="description">
    Web Advocate. Internetrovert. Craving simplicity, finding it nowhere. Engineer <a href="#">@Google</a>
  </section>
  <section class="homepage">
    <a href="#">keybase.io/surma</a>
  </section>
</header>
<section class="tweets">
  <section class="tweet">
    <img src="avatar.jpg" class="avatar">
    <section class="meta">
      <span class="name">Surma</span>
      <span class="handle">@DasSurma</span>
      <span class="date">Dec 27</span>
    </section>
    üìù New post-üéÑ blog post about architecture and web apps: The Actor Model and why I think it implies that DOM-in-workers is undesirable.
    <section class="media">
      <img src="media.jpg">
      <p class="title">‚ÄúAn Actor, a model and an architect walk onto the web...‚Äù ‚Äì DasSur.ma</p>
      <p class="domain">dassur.ma</p>
    </section>
  </section>
</section>
<script>
  async function init() {
    ['--avatar-size', '--header-height', '--font-base', '--bar-height', '--avatar-border']
      .forEach(name => {
        CSS.registerProperty({
          name,
          syntax: '<length>',
          initialValue: '0px',
          inherits: true
        });
      });

    await animationWorklet.addModule('twitter-header-animator.js');

    const sizes = document.documentElement.computedStyleMap();
    const scrollSource = document.body;
    const avatar = document.querySelector('.avatar');
    const bar = document.querySelector('.bar');
    const maxTime = 1000;
    const epsilon = 1e-2;
    const scrollTimeline = new ScrollTimeline({
      scrollSource,
      orientation: 'block',
      timeRange: maxTime,
    });
    const clientHeight = scrollSource.clientHeight;
    const scrollHeight = scrollSource.scrollHeight;

    const scrollSize = scrollHeight - clientHeight; // maximum scroll offset

    const avatarTargetScale = sizes.get('--bar-height').value / (sizes.get('--avatar-size').value + 2 * sizes.get('--avatar-border').value);
    const avatarScrollEndPos = (sizes.get('--header-height').value/2 - sizes.get('--avatar-size').value/2 - sizes.get('--avatar-border').value);
    const avatarTargetTranslate = scrollSize - avatarScrollEndPos;
    // Stop scaling at this offset and start transform.
    const avatarScrollEndOffset = avatarScrollEndPos / scrollSize;

    console.log(avatarScrollEndPos, avatarScrollEndOffset);
    console.log(scrollSize);
    const avatarEffect = new KeyframeEffect(avatar, [
      {transform: `translateY(0px) scale(1)`, easing: 'ease-in-out', offset: 0},
      {transform: `translateY(0px) scale(${avatarTargetScale})`, easing: 'linear', offset: avatarScrollEndOffset},
      {transform: `translateY(${avatarTargetTranslate}px) scale(${avatarTargetScale})`, offset: 1},
    ], {
      duration: maxTime + epsilon,
      fill: 'both',
      iterations: Infinity,
    });
      
    new WorkletAnimation('twitter-header',
      [avatarEffect],
      scrollTimeline,
      {}
    ).play();

    new WorkletAnimation('twitter-header',
      [
        new KeyframeEffect(bar, [
          {opacity: 0, offset: 0},
          {opacity: 1, offset: avatarScrollEndOffset},
          {opacity: 1, offset: 1}
        ], {
          duration: maxTime + epsilon,
          fill: 'both',
          iterations: Infinity, 
          /* crbug(779189): Use infinity iteration and maxDuration to avoid effect 
             prematurely finishing.

             BTW, Web Animations uses an endpoint-exclusive timing model, which mean
             when timeline is at "duration" time, it is considered to be at 0 time of the 
             second iteration. To avoid this, we ensure our max time (max scroll offset) never
             reaches duration by having duration an epsilon larger.  This hack is not
             needed once we fix the original bug above.
           */
        }),
      ],
      scrollTimeline,
      {}
    ).play();
    
    /* crbug(824782): delay is not working as expected in worklet, instead here we combine 
       what would have been a delayed animation with the other avatar animation but start
       it at a different offset.

      new WorkletAnimation('twitter-header',
        [
          new KeyframeEffect(avatar, [
            {transform: `translateY(0px)`},
            {transform: `translateY(${scrollHeight - clientHeight}px)`},
          ], {
            delay: avatarScrollEndPos/scrollHeight * maxTime,
            duration: (scrollHeight - clientHeight)/scrollHeight * maxTime,
            fill: 'both',
          }),
        ],
        scrollTimeline,
        {}
      )//.play();
    */
  }
  init();
</script>
